package hydrator

import (
	"fmt"
	"strings"
	"sync"

	"github.com/asecurityteam/nexpose-vuln-hydrator/pkg/domain"
)

// AssetVulnerabilityHydrator implements the domain.Hydrator interface for hydrating
// an asset's vulnerabilities
type AssetVulnerabilityHydrator struct {
	Client domain.NexposeClient
}

// HydrateVulnerabilities takes a domain.Asset and fetches its vulnerabilities to be further
// hydrated concurrently
func (a *AssetVulnerabilityHydrator) HydrateVulnerabilities(asset domain.Asset) (domain.AssetVulnerabilityDetails, error) {
	// For an asset - we first get the list of vulnerabilities for a given asset ID
	// For each vulnerability, we can fetch these concurrently, as seen on lines 35-41
	// For each vulnerability, we can fetch the details and solutions concurrently, as seen on lines 75-102
	// The solutions response gives a list of solution IDs, we can again fetch the solution details concurrently as seeon on lines 134-153

	// 1. fetch vulnerabilities to be hydrated - this contains contains the vulnerability ID (for further hydration)
	// as well as the results (port and protocol information of finding)
	vulnerabilities, err := a.Client.GetAssetVulnerabilities(asset.ID)
	if err != nil {
		return domain.AssetVulnerabilityDetails{}, err
	}

	vulnDetailsChan := make(chan domain.VulnerabilityDetails, len(vulnerabilities))
	errChan := make(chan error)

	var wg sync.WaitGroup
	wg.Add(len(vulnerabilities))
	for _, vuln := range vulnerabilities {
		// 2. fetch vulnerabilities concurrently, placing results and errors on channels
		go a.hydrateVulnerability(&wg, vuln, vulnDetailsChan, errChan)
	}
	wg.Wait()

	// 17. Again not sure how to capture all errors or if we want to
	errorsConcat := make([]string, len(errChan))
	for err := range errChan {
		errorsConcat = append(errorsConcat, err.Error())
	}

	if len(errorsConcat) > 0 {
		return domain.AssetVulnerabilityDetails{}, fmt.Errorf(strings.Join(errorsConcat, ","))
	}

	// 18. Otherwise, collect the vuln details and form the AssetVulnerabilityDetails
	vulnDetails := make([]domain.VulnerabilityDetails, len(vulnDetailsChan))
	for vulnDetail := range vulnDetailsChan {
		vulnDetails = append(vulnDetails, vulnDetail)
	}

	return domain.AssetVulnerabilityDetails{
		Asset:           asset,
		Vulnerabilities: vulnDetails,
	}, nil
}

func (a *AssetVulnerabilityHydrator) hydrateVulnerability(wg *sync.WaitGroup, vuln domain.NexposeAssetVulnerability, vulnDetailsChan chan domain.VulnerabilityDetails, errChan chan error) {
	// 3. this let's the callee (HydrateVulnerabilities) know that we're done hydrating an _individual vulnerability
	defer wg.Done()

	// 4. create _new_ wait group for getting vuln details and solutions concurrently - not too sure about this pattern
	var hydrationWg sync.WaitGroup
	// 5. chose to use a pointer here as we will get 1 result or error, nil check at the bottom of this func
	var nexposeVuln *domain.NexposeVulnerability
	var err error

	hydrationWg.Add(1)
	go func() {
		defer hydrationWg.Done()
		// 6. Get vuln details
		nexposeVuln, err = a.Client.GetVulnerabilityDetails(vuln.ID)
		if err != nil {
			errChan <- err
			return
		}
	}()

	hydrationWg.Add(1)
	// 7. make solutions channel for goroutines to fetch solution details to communicate over
	solutionsChan := make(chan string)
	go func() {
		defer hydrationWg.Done()
		// 8. get list of solution IDs for the vulnerability first
		solutionIDs, err := a.Client.GetVulnerabilitySolutions(vuln.ID)
		if err != nil {
			errChan <- err
			return
		}
		// 9. Add delta here for keeping track of the goroutine that fetches each solution IDs _actual_ solution (APIs are awesome)
		hydrationWg.Add(1)
		go a.fetchSolutions(&hydrationWg, solutionIDs, solutionsChan, errChan)
	}()

	hydrationWg.Wait()

	// 15. if there _are_ errors return - admittedly this is not well thought out, would love opinions
	// notably - no solutions might be an error, but should we handle it gracefully returning no solutions?
	if len(errChan) > 0 {
		return
	}

	// 16. if no errors, build up solutions and place details on the channel
	solutions := make([]string, 0)
	for solution := range solutionsChan {
		solutions = append(solutions, solution)
	}

	vulnDetailsChan <- domain.VulnerabilityDetails{
		ID:             vuln.ID,
		Results:        vuln.Results,
		CvssV2Score:    nexposeVuln.CvssV2Score,
		CvssV2Severity: nexposeVuln.CvssV2Severity,
		Description:    nexposeVuln.Description,
		Title:          nexposeVuln.Title,
		Solutions:      solutions,
	}
}

func (a *AssetVulnerabilityHydrator) fetchSolutions(wg *sync.WaitGroup, solutionIDs []string, solutionsChan chan string, errChan chan error) {
	// 10. let hydrateVulnerability know we're done fetching _all_ solutions
	defer wg.Done()

	// 11. create new WaitGroup to keep track of fetching each solution detail concurrently
	var solutionsWg sync.WaitGroup

	solutionsWg.Add(len(solutionIDs))
	for _, solutionID := range solutionIDs {
		go func(id string) {
			defer solutionsWg.Done()

			// 12. Fetch all solutions for a given ID
			solutions, err := a.Client.GetVulnerabilitySolutions(id)
			if err != nil {
				errChan <- err
				return
			}
			// 13. Put each solution on the channel
			for _, s := range solutions {
				solutionsChan <- s
			}
		}(solutionID)
	}

	// 14. wait for all solutions to finish
	solutionsWg.Wait()
}
